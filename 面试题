Spring中的设计模式

1.单例模式
2.克隆模式
3.模板模式
4.观察者模式(监听器 如ApplicationListener)
5.工厂模式 (BeanFactory)
6.适配器模式(AOP实现的Adivice 和interceptor)
7.装饰者模式 (包装模式 Wrapper/Decorator)
8.代理模式
9.策略模式(spring实例化用到的strategy模式,XmlBeanDefinitionReader,PropertiesBeanDefinitionReader)
10.责任链模式(AOP拦截链)
11.委托者模式(DelegationFilterProxy,整合shiro,SpringSecurity)


@Autowired 和 @Resource的区别
1.@Autowired 是spring提供的注解,按照类型来自动注入.
 require属性设置为false可以允许null
 结合@Qualififier("beanName")按照名字装配

2.@Resource 是由J2EE提供,默认按照ByName自动注入,也可用ByType

--------------------------------------------------------------------------------------------------------------


Spring中常用的注解
1.@ComponentScan 扫描指定目录下带@Component注解的类,启动类上不加自动扫描启动类及其子目录下的所有文件.
2.@Indexed 需要引入依赖 spring-context-indexer,编译过程中会生成一个META-INF/spring.components文件,优化启动效率(启动时读取这个文件来加载bean,减少了扫描路径创建bean的时间)
3.@Import可以用来注入bean,用来引入普通类如:

@Import(UserConfig.class)
@Configuration
public class UserConfiguration { 
}

以上可以把UserConfig类注入spring容器. 也可以直接在UserConfig类上加@Component,@Configuration 来实现相同效果.
在启动类上可以通过@Import(xxxxConfig.class) 这种方式来加载引入的jar包的配置.


重要:配合ImportSelector
Spring的@EnableCache 就是使用了@Import 和 ImportSelector接口
例:@EnableCache 注解上有@Import(CacheConfigurationSelector.class)
CacheConfigurationSelector实现了AdviceModeImportSelector,而AdviceModeImportSelector实现了ImportSelector接口.
selectImports()内部就实现了根据@EnableCaching 中的值来确定AdviceMode

重要:配合ImportBeanDefinitionRegister
当配置类实现了 ImportBeanDefinitionRegistrar 接口，你就可以自定义往容器中注册想注入的Bean。
与selectImports接口不同的是,selectImports不能对这个类进行任何操作,ImportBeanDefinitionRegistrar可以自己注入BeanDefinition. 
通过ImportBeanDefinitionRegistrar接口的registerBeanDefinitions()方法来实现.
比如Mybatis的@MapperScan 和 Feign @EnableFeignClients 就是通过这种方式实现的


--------------------------------------------------------------------------------------------------------------


spring中的单例bean和原型bean

单例bean:spring中的bean默认就是单例.通过@Bean @Component @Configuration等注解标注的都是单例bean
原型bean:每次使用该bean,都是框架去重新创建一个bean,你永远不可能取到想同的对象.通过@@Scope(value = BeanDefinition.SCOPE_PROTOTYPE)可以创建原型bean. 原型bean不受spring容器管理,但还是会被GC回收
https://www.jianshu.com/p/b894edef2966

---------------------------------------------------------


Bean的作用域
prototype
singleton(默认)
request
session
global-session



https://blog.51cto.com/u_15903651/7416599
-----------------------------------------------------------


循环依赖的理解

bean实例化后,bean的初始化赋值有两种方法,构造方法注入和set方法注入

构造方法注入无法解决循环依赖问题,启动时候检查是否有循环依赖,会抛出异常.
set注入通过三级缓存的方法去解决循环依赖

----------------------------------------------------------------

数据库并发下的三种现象
1.脏读:当事务A正在访问数据,修改数据时,事务B也在访问数据,事务A读取使用了事务B未提交的数据.
2.不可重复读:事务A读取了事务B提交的数据.(数据值变更)
3.幻读:事务A读取了事务B提交的事务.(数据量变更)

不可重复读可以通过行锁解决,幻读要表级锁才可以解决.
事务的隔离级别

事务的隔离级别
读未提交 read-uncommitted
读提交 read committed
可重复度 repeatable read  (InnoDB默认)
串行化 Serializable


-------------------------------------------------------------------

Spring中的事务
1.spring事务分为声明式事务管理和编程式事务管理
声明式通过注解(@Transactional)

去实现编程式通过TransactionTemplate或者PlatformTransactionManager去实现.


------------------------------------------------------------------

线程的状态
CPU
1.新建状态（new）
2.就绪状态（ready）
3.运行状态（running）
4.等待状态（waiting）  wait(),sleep(),join() 方法执行进入
5.结束状态（terminated）

JAVA
@see java.lang.Thread   state
1.NEW 新建
2.RUNNABLE 可执行的，包括运行与非运行状态
3.BLOCKED 没拿到syn 锁时，处于blocked
4.WAITING 被wait(),join(),park() 没有时间限制挂起时，处于waiting状态，需要唤醒
5.TIMED_WAITING 有时间限制的等待，sleep(),wait(),join(),parkNanos(),parkUnitil()
6.TERMINATED 结束

------------------------------------------------------------------------

如何停止线程
1. stop() 不推荐，已过时
2.使用共享变量
3.interrupt  线程有一个interrupt标记位，默认为false，执行interrupt后，变为false，线程会停止

------------------------------------------------------------------------

sleep和wait

1.sleep()属于Thread类中的static方法 ， wait() 属于Object类方法
2.sleep使线程进入TIMED_WAITING,自动唤醒。 wait方法执行后线程进入WAITING状态，需手动唤醒。
3.sleep在持有锁时执行，不会释放锁资源。wait在执行后，会释放锁资源。
4.sleep在有锁或无锁时皆可执行，wait必须在有锁时执行。

wait方法会将持有锁的线程从owner扔到WaitSet集合中，这个操作是在修改ObjectMonitor对象，如果没有持有syn锁的话，无法操作ObjectMonitor对象。


------------------------------------------------------------------------

并发编程的三大特性
原子，可见，有序

1.如何保障原子性
1.1 synchronized

1.2 CAS
	comparer and swap 乐观锁，Unsafe类提供了对CAS的操作方法，详见原子类AtomicInteger等。
1.3 Lock锁
	ReentrantLock 基于CAS 和AQS

1.4 ThradLocal 


--------------------------------------------------------------------------

关于BIO,NIO,AIO

BIO
传统的io模型,在读写数据的时候会发生阻塞现象.当用户线程发出请求之后,内核回去查看数据是否就绪,如果没有就绪就会等待数据就绪,而用户线程就处于阻塞状态,用户线程交出CPU. 当数据就绪后,内核会将数据拷贝到用户线程,并返回给用户,这时才会接触block状态.典型阻塞IO(BIO):data = socket.read()


非阻塞io,用户线程发起read()后,无需等待,马上得到结果.如果结果是error时,他可以再次发起read操作.一旦内核准备好数据,就会马上拷贝到用户线程. NIO 会不断的询问内核是否准备就绪,也就是说NIO不会交出CPU,会一直占用CPU.如下:
while(true){
	data = socket.read();//事实上read也是阻塞的,这边仅作参考
	if(data!= error){
		//处理数据
		break;
	}
}


NIO(多路复用IO)
java 的nio是多路复用io. 在nio中,会有一个线程不断去轮询多个socket状态,只有当socket有真正读写事件时才会进行读写操作.
相比上面的while方式,nio只需要一个线程,即可管理多个socket,大大减少了CPU资源. 在java NIO中,使用selector.select()去查询每个通道是否有到达事件.
NIO比非阻塞IO效率高是因为NIO在内核中的轮询比用户线程去轮询效率高很多.

详见JAVA ServerSocketChannel   channel /selector

AIO(异步IO)
BIO和NIO都是同步IO,AIO是异步IO(JAVA详见AsynchronousServerSocketChannel)
异步IO需要操作系统支持,windows的IOCP技术支持异步IO,Linux则通过epoll模拟支持异步IO
同步IO是轮询方式,异步IO是订阅-通知方式.


生产中一般使用NIO框架Netty()
Netty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。












