---
typora-copy-images-to: image
---

## JVM虚拟机

**运行时数据区**



![](C:\Users\54286\Desktop\文档\笔记\image\1661416266228.png)

- 方法区

  存储类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

  - 运行时常量池

    这是方法区的一部分，class文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量与符号引用。

- 堆

  存放对象实例和数组（虚拟机栈的局部变量表会存放对象或者数组的动态连接，用来指向堆中的对象实例和数组）。GC就发生在堆中，-Xmx和-Xms设置堆内存。

- 虚拟机栈

  生命周期与线程相同，是描述Java方法执行的线程内存模型：$\textcolor{red}{每个方法被执行的时候，都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。}$

  每一个战帧对应一个方法的执行，一个栈帧保存该方法中的信息，如局部变量，方法出口，动态连接等。但当调用的方法数超过栈帧设定的深度时会爆出StackOverflowError异常，只需要递归，就可以触发这种异常。

- 本地方法栈

  发挥的作用与虚拟机栈十分相似，区别是本地方法栈是调用native方法时使用。

- 程序计数器

  线程私有，记录当前线程正在执行的虚拟机字节指令地址，没有规定$\textcolor{red} {OutOfMemoryError}$



###栈帧

栈帧是构成虚拟机栈的级别单位，一个栈帧表示一个方法的调用到返回。包括

- 局部变量表
- 方法返回地址
- 操作数栈
- 动态链接
- 附加信息

####局部变量表

定义为一个数字数组，用于存储方法参数和局部变量，因为局部变量表是线程私有的，故不存在线程安全问题。

$\textcolor{red}{在栈帧中，局部变量表与性能调优最为密切，在方法执行时，虚拟机使用局部变量表完成方法的传递。}$

$\textcolor{red}{局部变量表中的变量时重要的垃圾回收根节点（垃圾回收算法：可达性算法），只要被局部变量表中直接或者间接引用的对象，都不会被回收。}$

查看字节码命令：```javap -v InternTest.class```

```

public class InternTest {
    public static void main(String[] args) {
        InternTest internTest = new InternTest();
        String s = new String("a");
        int a = 1;
    }
}
```

**字节码中的本地变量表**

```
 LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      21     0  args   [Ljava/lang/String;
            8      13     1 internTest   LInternTest;
           18       3     2     s   Ljava/lang/String;
           20       1     3     a   I
```

**局部变量表的容量以变量槽（Variable Slot）为最小单位，范例中有4个本地变量，分别放置在下标0~3的变量槽中。**

name 为 args的变量解析 $\textcolor{red}{[Ljava/lang/String;}$

**[** 表示这是一个数组

**L** 表示这是引用数据类型

**java/lang/String;** 表示这是String类型

依次类推，**I**表示Int ，**LInternTest**表示这是InternTest对象，引用数据类型



**jclasslib**

![](C:\Users\54286\Desktop\文档\笔记\image\屏幕截图 2022-08-30 164155.png)

在方法标签中，列出了当前class文件的所有方法

####操作数栈

一个后进先出的操作数栈，也称为表达式栈，用于执行方法的字节码指令。

**代码**

````java
public static void main(String[] args) {
        byte i = 15;  //byte、short、char、boolean 、int：都以int型来保存，故字节码指令用bipush
        int j = 8;
        int k = i+j;
}
````



**字节码**

```
 0 bipush 15    1. 将int 15 入栈
 2 istore_1	 	2. 将 15 放入局部变量表 index1 中 ，index0放this
 3 bipush 8		3.将 int 8 入栈
 5 istore_2		4.将 8放入局部变量表index2中
 6 iload_1		5.将 局部变量表index1 值取出并入栈
 7 iload_2		6.将 局部变量表index2 值取出并入栈
 8 iadd			7.将操作数栈中的值相加
 9 istore_3		8.将相加所得的值放入index3局部变量表中
10 return		9.返回
```

1.*当 int 取值 -1~5 采用 iconst 指令，取值 -128~127 采用 bipush 指令（byte），取值 -32768~32767 采用 sipush 指令（short），取值 -2147483648~2147483647 采用 ldc 指令。* 

PC寄存器作为线程私有的存在，会记录操作数栈执行的指令集数。

操作数栈的深度是程序编译的时候就确定的。

如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新下一条需要执行的字节码指令。

i++问题

```
public int iTest(){
        //1
        int i1 =10;
        i1++;
        int i2=10;
        ++i2;

        //2
        int i3 =10;
        int i4=i3++;

        int i5=10;
        int i6=++i5;

        //3
        int i7 = 10;
        i7 = i7++;

        int i8 =10;
        i8 =++i8;

        //4
        int i9=10;
        int i10=i9++ + ++i9;

        return 0;
    }
```

```
0 bipush 10
 2 istore_1
 3 iinc 1 by 1	//index1 增加1
 6 bipush 10
 8 istore_2
 9 iinc 2 by 1
12 bipush 10
14 istore_3
15 iload_3
16 iinc 3 by 1
19 istore 4
21 bipush 10
23 istore 5
25 iinc 5 by 1
28 iload 5
30 istore 6
32 bipush 10
34 istore 7
36 iload 7
38 iinc 7 by 1
41 istore 7
43 bipush 10
45 istore 8
47 iinc 8 by 1
50 iload 8
52 istore 8
54 bipush 10
56 istore 9
58 iload 9
60 iinc 9 by 1
63 iinc 9 by 1
66 iload 9
68 iadd
69 istore 10
71 iconst_0
72 ireturn
```



####栈顶缓存技术

基于栈式架构的虚拟机所使用的零地址指令更加紧凑（没有索引的缘故），但完成一项操作必然需要更多的出栈和入栈指令，意味着更多的指令分派次数和内存读写次数。

栈顶缓存技术就是将栈顶元素全部缓存在物理CPU的寄存器中，以此来降低堆内存的读写次数，提升执行引擎的效率。

#### 方法返回地址

存放调用该方法的PC寄存器的值。

一个方法的结束有两种方法：

- 正常执行完成
- 未出现未处理异常，非正常退出

无论通过哪种方式推出，都会返回该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令地址。而通过异常退出的，返回地址要通过异常表来确定，栈帧中一般不会保存这部分信息。

#### 动态链接

每个栈帧都包含一个指向运行时常量池（位于方法区中）中该栈帧所属的方法的引用。包含这个引用的目的就是为了支持当前的方法的代码能实现动态链接。

![屏幕截图 2022-09-19 155822](C:\Users\54286\Desktop\文档\笔记\image\屏幕截图 2022-09-19 155822.png)

java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存到class文件的常量池中。描述一个方法调用另一个方法时，通过常量池中指向方法的符号引用来表示。

$\textcolor{red}{动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。}$

#### 动态链接和静态链接

- 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
- 如果被调用的方法在编译期无法被确定下来，只能在程序运行期将调用方法的符号引用转换为直接引用，称之为动态链接。

###### 方法调用指令

- invokestatic 调用静态方法，解析阶段确定唯一方法版本
- invokespecial 调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
- invokevirtual 调用所有虚方法
- invokeinterface 调用接口方法

###### 动态调用指令

- invokedynamic 动态解析出需要调用的方法，然后执行

前四条固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确认方法版本。其中invokestatic指令和invokespecial指令调用方法称为非虚方法，其余（final修饰除外）称为虚方法。

### 堆

- 一个JVM实例只存在一个堆内存，堆是JAVA内存管理的核心区域。
- JAVA堆区在JVM启动的时候就被创建，其空间大小也就确定了。
- 所有线程共享JAVA堆，但还可以在这里划分线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）

**所有的对象实例以及数组都应当在运行时分配在堆上。**

```
-Xms10m 最小分配空间
-Xmx10m	最大分配空间
-XX:+PrintGCDetails 打印堆空间详细信息
-XX:NewRatio=2（默认值） ,表示新生代占1，老年代占2，新生代占整个堆的1/3
-XX:SurvivorRatio=8 Eden空间和另外两个survivor空间的占比m默认情况为8:1:1
-XX:MaxTenuringThreshould 设置新生代垃圾的最大年龄
-XX:-UseAdaptiveSizePolicy # -表示停止自适应，+表示开启，默认开启，这个参数会影响新生代的空间分配
-Xmn 设置新生代空间的大小
-XX:+PrintFlagsFinal 查看所有的参数最终值
-XX:+PrintFlagsInitial 查看所有参数的默认初始值
-XX:HandlePromotionFailure 是否设置空间分配担保
```

-XX:+PrintGCDetails 打印日志信息解析

![](C:\Users\54286\Desktop\文档\笔记\image\20200314215636987.png)

**控制台指令**

- jps #查看进程
- jstat -gc pid

![](C:\Users\54286\Desktop\文档\笔记\image\gc.png)

*S0C：第一个幸存区的大小*
*S1C：第二个幸存区的大小*
*S0U：第一个幸存区的使用大小*
*S1U：第二个幸存区的使用大小*
*EC：伊甸园区的大小*
*EU：伊甸园区的使用大小*
*OC：老年代大小*
*OU：老年代使用大小*
*MC：方法区大小*
*MU：方法区使用大小*
*CCSC:压缩类空间大小*
*CCSU:压缩类空间使用大小*
*YGC：年轻代垃圾回收次数*
*YGCT：年轻代垃圾回收消耗时间*
*FGC：老年代垃圾回收次数*
*FGCT：老年代垃圾回收消耗时间*
*GCT：垃圾回收消耗总时间*

*ps:之前的PC 和PU 被MC MU取代了。（永久代）*

- jinfo -flag NewRatio pid

*堆空间内存大小 = 新生代+老年代*

#### 新生代

- 幸存者1区
- 幸存者2区
- 伊甸园区

#### 新生代对象分配与回收

1. new的对象先放在eden区。此区有大小限制

2. 当eden区填满时，程序又需要创建对象，JVM垃圾回收器会对伊甸园区进行垃圾回收（Minor GC）,将伊甸园区不再被其他对象引用的对象进行销毁。再加载新的对象到伊甸园区。
3. 然后将剩余的对象移动到幸存者0区。
4. 第二次触发垃圾回收（此时上次幸存下来的对象还放在幸存者0区，如果没有回收，就会被放到幸存者1区）。
5. 之后每次触发YGC，s1和s2互相倒腾（确保一个区是空的，一个区是有对象的）
6. 每次触发ygc，对象标记都会+1，到15次时，放入老年区。（-XX:MaxTenuringThreshold=<N> 设置临界值）
7. YGC在Dden区满时触发YGC

#### 老年代

​	老年代发生的GC称为Major GC 或者 Full GC。

​	FullGC 比Ygc慢十倍以上

​	Full GC 触发机制：

1. 调用System.gc()时，系统建议执行Full GC，但是不是必然执行
2. 老年代空间不足时
3. 方法区空间不足时
4. 通过Minor GC 后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区，survivor space0 区向survivor space1区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代可用内存小于该对象内存。

$\textcolor{red}{开发中应该避免Full GC 的频繁执行}$

###### TLAB(Thread Local Allocation Buffer)

TLAB，全称 Thread Local Allocation Buffer，即线程本地分配缓存。是一块 **线程专用** 的内存分配区域。TLAB 占用的是 *eden* 区的空间，在 TLAB 启用的情况下（默认开启），JVM 会为每一个线程分配一块私有缓存区域区域，即为 TLAB 内存区域。

尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。

- **加速对象的分配**。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须线程同步，会使分配的效率下降。
- 多线程同时分配内存时，使用 TLAB 可以 **避免一系列的非线程安全问题**，同时还能够 **提升内存分配的吞吐量**，因此我们可以将这种内存分配方式称为 **快速分配策略**。

#### 代码优化

###### 栈上分配

**堆是分配对象存储的唯一选择吗？**

​	由于即时编译技术的进步，尤其是逃逸分析技术的日益强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说对象实力都分配在堆上不在变得那么绝对了。

​	**在对象的分配过程中，如果经过逃逸分析，一个对象并没有逃逸出方法的话，那么就可能被优化为栈上分配。这样这个对象就不用在堆上分配内存，也不需要垃圾回收了**

###### 同步省略

​	在动态编译同步块的时候，JIT编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程**。如果没有，JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫**锁消除**。

###### 标量替换

​	有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存而是存储在栈中。

​	标量是指一个无法再分解的数据（基本数据类型），可以分解的叫做聚合量，比如对象。JIT阶段，经过逃逸分析，发现一个对象不会被外界访问的话，经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

```
//User是一个聚合量（如果User里面还有对象，可继续分解）
main(){
    User user =new User();
    sout(user.toString());
}
class User{
    int age;
    int id;
}
```

```
//因为new 出来的User没有逃逸出main方法，经过聚合分解后，就会分解成方法中的两个局部变量，这就是标量替换
main(){
    int age = 0;
    int id = 0;
    sout(user.toString());
}
```











 

 

 

 

 

 

 

 

 

### 方法区

###### 元空间Metaspace（方法区的实现）

元空间和堆是线程共享的。

方法区不会因为堆空间的GC而垃圾回收。但方法区也会根据需要进行垃圾回收和压缩。



## 字节码

#### 加载load和存储store指令

分为load，store，常量加载三种

- load 类

  比如iload_0将局部变量表中下标为0的int型变量加载到操作数栈上，根据不同的数据变量类型还有lload、fload、dload、aload这些指令，分别代表long、float、double、引用类型的变量。 

- store类

  store类指令是将栈顶的数据存储到局部变量表中。 比如istore_0是将操作数栈顶的int类型元素存储到局部变量表中下标为0的位置。 根据不同的数据变量类型还有lstore、fstore、dstore、astore这些指令。 

- 常量加载

  常见的有const类、push类、ldc类。
  const、push类指令是将常量值直接加载到操作数栈顶，如iconst_0是将整数0加载到操作数栈顶，bipush100是将int类型100加载到操作数栈顶。
  ldc指令是从常量池加载对应的常量到操作数栈顶，如ldc #10是将常量池中下下标为10的常量数据加载到操作数栈顶。#表示常量池的下标。
  















































