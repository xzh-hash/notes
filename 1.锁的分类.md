### 1.锁的分类

乐观锁,悲观锁
公平锁,非公平锁
独占锁,共享锁
偏向锁,轻量级锁,重量级锁



### 2.锁的详细介绍

2.1 乐观锁

通过CAS 方式实现,具体就是版本号或者时间戳等方式实现.

BigDecimal 类就是通过CAS实现.

数据库中的乐观锁是通过版本号字段去实现.



关于CAS 

```
compareAndSet方法具有原子性,是通过native方法来实现的
```

ABA问题

通过加版本号去实现.详见AtomicStampedReference



2.2悲观锁

在java中,悲观锁通过AQS实现(Abstract Queened synchronzied  抽象队列同步器)

在数据库中,使用 for update来锁定





3.Synchronized

**syn属于悲观锁,独占锁,可重入锁**

syn的作用范围可以是代码块,实例方法或者静态方法.

syn是一种内置的并发控制机制,其原理涉及到JVM内部的监视器锁(monitor lock)和锁的各个区域.

**EntryList**:存储等待获取锁的线程列表.

**ContentionList**:存储正在竞争锁的线程列表.

**ExitList**:存储即将释放锁的线程列表.

**WaiterSet**:存储正在等待通知的线程列表 .

**Owner**：存储持有锁的线程。

**EntryMonitor**：存储监视器锁（monitor lock）

1.6之后对Synchronized进行了大量优化



锁升级:

**无状态**

偏向锁启动,一个线程加锁,将线程id写入对象头markword

**偏向锁**

多个线程加锁,cas轻度竞争

**轻量级锁**

CAS自旋不成功(锁膨胀)

重度竞争,自适应自旋

**重量级锁**





4.ReentrantLock

reentrantLock是可重入锁和独占锁

ReentranLock类中有一个state作为锁,线程通过CAS尝试去获取锁,

当无法获取锁时会放在一个双向链表中,线程通过LockSupport.park()停止,

LockSupport.unpark()唤醒.



##### 什么是AQS?

AQS就是java中JUC包下的抽象类AbstractQueuedSynchronizer

ReentrantLock，ReentrantReadWriteLock，CountDownLatch，线程池，CyclicBarrier等等都是通过AQS实现的.

AQS三个核心内容

state: int类型作为锁,等于0是未锁,等于1时锁住

双向链表: 用来存放那些未竞争到锁的线程,这些线程会被park(),等待唤醒

单向链表: 单向链表是只有lock锁的线程，在执行了await（相当于synchronized的wait）方法，线程会释放掉锁资源，然后添加到这个单向链表中，然后挂起线程。在wait状态的线程被signal（相当于synchronized的notify）方法唤醒后，会从单向链表扔到双向链表中等待获取锁资源 

